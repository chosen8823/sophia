# docker-compose.yml - Complete Deployment Configuration
version: '3.8'

services:
  # Backend API Service
  manus-backend:
    build: 
      context: ./manus_platform_backend
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=sqlite:///data/manus_platform.db
      - SECRET_KEY=manus-spiritual-ai-platform-2025-secure
      - HUGGINGFACE_API_KEY=${HUGGINGFACE_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - N8N_WEBHOOK_URL=http://n8n:5678
    volumes:
      - manus_data:/app/data
      - manus_logs:/app/logs
    restart: unless-stopped
    networks:
      - manus-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Frontend Service
  manus-frontend:
    build:
      context: ./manus_platform_frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - manus-backend
    restart: unless-stopped
    networks:
      - manus-network
    volumes:
      - ./ssl:/etc/nginx/ssl:ro

  # n8n Workflow Automation
  n8n:
    image: n8nio/n8n:latest
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=manus2025secure
      - N8N_HOST=0.0.0.0
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      - NODE_ENV=production
    volumes:
      - n8n_data:/home/node/.n8n
    restart: unless-stopped
    networks:
      - manus-network

  # Redis for Caching (Optional)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - manus-network
    command: redis-server --appendonly yes

  # PostgreSQL Database (Optional upgrade from SQLite)
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=manus_platform
      - POSTGRES_USER=manus
      - POSTGRES_PASSWORD=manus_secure_2025
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - manus-network
    ports:
      - "5432:5432"

  # Nginx Reverse Proxy
  nginx:
    image: nginx:alpine
    ports:
      - "8080:80"
      - "8443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - manus-backend
      - manus-frontend
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  manus_data:
    driver: local
  manus_logs:
    driver: local
  n8n_data:
    driver: local
  redis_data:
    driver: local
  postgres_data:
    driver: local

networks:
  manus-network:
    driver: bridge

---

# Backend Dockerfile
# manus_platform_backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY src/ ./src/
COPY . .

# Create data and logs directories
RUN mkdir -p /app/data /app/logs

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/api/health || exit 1

# Run application
CMD ["python", "src/main.py"]

---

# Frontend Dockerfile  
# manus_platform_frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built files
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf

# Expose ports
EXPOSE 80 443

# Start nginx
CMD ["nginx", "-g", "daemon off;"]

---

# Nginx Configuration
# nginx.conf
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    
    # Upstream backend
    upstream manus_backend {
        server manus-backend:5000;
    }
    
    # Main server block
    server {
        listen 80;
        server_name localhost manus.local;
        
        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
        
        # Serve frontend
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
            
            # Cache static assets
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }
        
        # API proxy
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            
            proxy_pass http://manus_backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
            
            # CORS headers
            add_header Access-Control-Allow-Origin "http://localhost:5173" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization" always;
            add_header Access-Control-Allow-Credentials "true" always;
            
            # Handle preflight requests
            if ($request_method = 'OPTIONS') {
                return 204;
            }
        }
        
        # n8n proxy
        location /n8n/ {
            proxy_pass http://n8n:5678/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }
        
        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
    
    # SSL server block (if certificates available)
    server {
        listen 443 ssl http2;
        server_name localhost manus.local;
        
        # SSL configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_session_timeout 1d;
        ssl_session_cache shared:MozTLS:10m;
        ssl_session_tickets off;
        
        # Modern configuration
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        
        # HSTS
        add_header Strict-Transport-Security "max-age=63072000" always;
        
        # Same location blocks as HTTP server
        include /etc/nginx/conf.d/common-locations.conf;
    }
}

---

# Environment Configuration
# .env.example
# Copy to .env and fill in your values

# Flask Configuration
FLASK_ENV=production
SECRET_KEY=your-super-secret-key-here
DATABASE_URL=sqlite:///data/manus_platform.db

# AI API Keys (Optional but recommended)
HUGGINGFACE_API_KEY=your_huggingface_api_key
OPENAI_API_KEY=your_openai_api_key

# n8n Configuration
N8N_WEBHOOK_URL=http://localhost:5678
N8N_BASIC_AUTH_USER=admin
N8N_BASIC_AUTH_PASSWORD=secure_password

# Redis Configuration (Optional)
REDIS_URL=redis://redis:6379/0

# PostgreSQL Configuration (Optional)
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_DB=manus_platform
POSTGRES_USER=manus
POSTGRES_PASSWORD=secure_password

# SSL Configuration
SSL_CERT_PATH=/etc/nginx/ssl/cert.pem
SSL_KEY_PATH=/etc/nginx/ssl/key.pem

# Logging
LOG_LEVEL=INFO
LOG_FILE=/app/logs/manus.log

---

# Production Requirements
# manus_platform_backend/requirements.prod.txt
Flask==2.3.3
Flask-CORS==4.0.0
Flask-SQLAlchemy==3.0.5
Flask-Migrate==4.0.5
Flask-Login==0.6.3
Flask-JWT-Extended==4.5.3
Flask-Limiter==3.5.0
Flask-Caching==2.1.0
requests==2.31.0
aiohttp==3.9.0
asyncio
uvloop==0.19.0

# AI/ML Libraries
transformers==4.35.0
torch==2.1.0
sentence-transformers==2.2.2
openai==1.3.0
huggingface-hub==0.17.3

# Database
psycopg2-binary==2.9.7
redis==5.0.1
alembic==1.12.1

# Production WSGI Server
gunicorn==21.2.0
gevent==23.9.1

# Monitoring and Logging
prometheus-client==0.18.0
structlog==23.2.0
python-json-logger==2.0.8

# Security
cryptography==41.0.7
bcrypt==4.1.1
PyJWT==2.8.0

# Utilities
python-dotenv==1.0.0
click==8.1.7
pydantic==2.5.0
marshmallow==3.20.1

---

# Kubernetes Deployment (Optional)
# k8s-deployment.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: manus-platform

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: manus-backend
  namespace: manus-platform
spec:
  replicas: 3
  selector:
    matchLabels:
      app: manus-backend
  template:
    metadata:
      labels:
        app: manus-backend
    spec:
      containers:
      - name: manus-backend
        image: manus/backend:latest
        ports:
        - containerPort: 5000
        env:
        - name: FLASK_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: manus-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: manus-secrets
              key: secret-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: manus-backend-service
  namespace: manus-platform
spec:
  selector:
    app: manus-backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5000
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: manus-frontend
  namespace: manus-platform
spec:
  replicas: 2
  selector:
    matchLabels:
      app: manus-frontend
  template:
    metadata:
      labels:
        app: manus-frontend
    spec:
      containers:
      - name: manus-frontend
        image: manus/frontend:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

---
apiVersion: v1
kind: Service
metadata:
  name: manus-frontend-service
  namespace: manus-platform
spec:
  selector:
    app: manus-frontend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: LoadBalancer

---

# Helm Chart Values
# helm/manus-platform/values.yaml
replicaCount: 3

image:
  backend:
    repository: manus/backend
    tag: "latest"
    pullPolicy: IfNotPresent
  frontend:
    repository: manus/frontend
    tag: "latest"
    pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: "nginx"
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: manus.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: manus-tls
      hosts:
        - manus.example.com

resources:
  backend:
    limits:
      cpu: 500m
      memory: 1Gi
    requests:
      cpu: 250m
      memory: 512Mi
  frontend:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80

postgresql:
  enabled: true
  auth:
    postgresPassword: "secure_password"
    database: "manus_platform"

redis:
  enabled: true
  auth:
    enabled: false

---

# CI/CD Pipeline (GitHub Actions)
# .github/workflows/deploy.yml
name: Deploy Manus Platform

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        cd manus_platform_backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run tests
      run: |
        cd manus_platform_backend
        python -m pytest tests/ -v
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install frontend dependencies
      run: |
        cd manus_platform_frontend
        npm ci
        
    - name: Build frontend
      run: |
        cd manus_platform_frontend
        npm run build
        
    - name: Run frontend tests
      run: |
        cd manus_platform_frontend
        npm test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata (tags, labels) for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
        
    - name: Build and push backend Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./manus_platform_backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        
    - name: Extract metadata (tags, labels) for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
        
    - name: Build and push frontend Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./manus_platform_frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /opt/manus-platform
          git pull origin main
          docker-compose pull
          docker-compose up -d --force-recreate
          docker system prune -f

---

# Monitoring Configuration
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'manus-backend'
    static_configs:
      - targets: ['manus-backend:5000']
    metrics_path: '/api/metrics'
    scrape_interval: 5s
    
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:9113']
      
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

---

# Alert Rules
# monitoring/alert_rules.yml
groups:
- name: manus-platform-alerts
  rules:
  - alert: HighErrorRate
    expr: rate(flask_http_request_exceptions_total[5m]) > 0.1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High error rate detected"
      description: "Error rate is {{ $value }} errors per second"
      
  - alert: HighMemoryUsage
    expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes > 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "High memory usage"
      description: "Memory usage is above 90%"
      
  - alert: ServiceDown
    expr: up == 0
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "Service is down"
      description: "{{ $labels.instance }} has been down for more than 1 minute"

---

# Backup Script
# scripts/backup.sh
#!/bin/bash
set -e

# Configuration
BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)
DB_BACKUP_NAME="manus_db_backup_${DATE}.sql"
FILES_BACKUP_NAME="manus_files_backup_${DATE}.tar.gz"

# Create backup directory
mkdir -p ${BACKUP_DIR}

echo "Starting backup process..."

# Backup database
echo "Backing up database..."
docker exec manus-postgres pg_dump -U manus -d manus_platform > ${BACKUP_DIR}/${DB_BACKUP_NAME}

# Backup uploaded files and data
echo "Backing up files..."
docker run --rm -v manus_data:/data -v ${BACKUP_DIR}:/backup alpine tar czf /backup/${FILES_BACKUP_NAME} -C /data .

# Backup n8n workflows
echo "Backing up n8n workflows..."
docker exec n8n n8n export:workflow --backup --output=/home/node/.n8n/backups/workflows_${DATE}.json

# Clean old backups (keep last 7 days)
echo "Cleaning old backups..."
find ${BACKUP_DIR} -name "*.sql" -mtime +7 -delete
find ${BACKUP_DIR} -name "*.tar.gz" -mtime +7 -delete

# Upload to cloud storage (optional)
if [ ! -z "$AWS_S3_BUCKET" ]; then
    echo "Uploading to S3..."
    aws s3 cp ${BACKUP_DIR}/${DB_BACKUP_NAME} s3://${AWS_S3_BUCKET}/backups/
    aws s3 cp ${BACKUP_DIR}/${FILES_BACKUP_NAME} s3://${AWS_S3_BUCKET}/backups/
fi

echo "Backup completed successfully!"

---

# Health Check Script
# scripts/health_check.sh
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to check service health
check_service() {
    local service_name=$1
    local url=$2
    local expected_status=${3:-200}
    
    echo -n "Checking ${service_name}... "
    
    status_code=$(curl -s -o /dev/null -w "%{http_code}" ${url} || echo "000")
    
    if [ "${status_code}" = "${expected_status}" ]; then
        echo -e "${GREEN}✓ Healthy${NC}"
        return 0
    else
        echo -e "${RED}✗ Unhealthy (${status_code})${NC}"
        return 1
    fi
}

# Function to check Docker container
check_container() {
    local container_name=$1
    
    echo -n "Checking ${container_name} container... "
    
    if docker ps --format "table {{.Names}}" | grep -q "^${container_name}$"; then
        echo -e "${GREEN}✓ Running${NC}"
        return 0
    else
        echo -e "${RED}✗ Not running${NC}"
        return 1
    fi
}

echo "=== Manus Platform Health Check ==="
echo

# Check containers
check_container "manus-backend"
check_container "manus-frontend" 
check_container "n8n"
check_container "redis"

echo

# Check services
check_service "Backend API" "http://localhost:5000/api/health"
check_service "Frontend" "http://localhost:80"
check_service "n8n" "http://localhost:5678"

echo

# Check disk space
echo -n "Checking disk space... "
disk_usage=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
if [ ${disk_usage} -lt 90 ]; then
    echo -e "${GREEN}✓ OK (${disk_usage}% used)${NC}"
else
    echo -e "${YELLOW}⚠ Warning (${disk_usage}% used)${NC}"
fi

# Check memory usage
echo -n "Checking memory usage... "
memory_usage=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100.0}')
if [ ${memory_usage} -lt 90 ]; then
    echo -e "${GREEN}✓ OK (${memory_usage}% used)${NC}"
else
    echo -e "${YELLOW}⚠ Warning (${memory_usage}% used)${NC}"
fi

echo
echo "=== Health Check Complete ==="